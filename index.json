[{"categories":null,"content":"This page is about me and my technical background","date":"2021-01-28","objectID":"/info/about/","tags":null,"title":"About me","uri":"/info/about/"},{"categories":null,"content":" \rMechanical engineer and maker. I love to come up with unique solutions for unkown problems and this is the right space for my personal projects that what to be noticed :). What is this Blog about?\r\rI have done several projects in the past involving arduinos, mechatronics or simple mechanical designs mostly around 3d printing. However in the future i also want to share some more software orientated projects and creative stuff that comes into my mind. So stay tuned!! \r\r ","date":"2021-01-28","objectID":"/info/about/:0:0","tags":null,"title":"About me","uri":"/info/about/"},{"categories":["arduino","feedback control theory"],"content":"Introduction The inverted pendulum is one of the most popular demonstrations in system control, has been studied since the 19601 and is a prime example at unis and other research institutes. However, the inverted pendulum, which is nothing more than a pendulum that has the centre of mass above the pivot point, yet has no particular use case. To change this once in for all, I build an inverted pendulum lamp, which can be used as a normal stylish desk lamp. (The main incentive, however, wasn‚Äôt so heroic. Honestly! It sounded just like a nice project idea!) Note\r\rThis blog post will give you a step by step recreation guide and highlights the design choices I made as well as introduce you to the implementation of the LQR Control Algorithm I used to balance the Lamp. I will also mention the resources that I used to speed up the programming part at the end of the post!\r\r ","date":"2020-08-31","objectID":"/inverted_pendolum/:1:0","tags":["electronics","dc-motor","L298n","lamp"],"title":"Inverted Pendulum","uri":"/inverted_pendolum/"},{"categories":["arduino","feedback control theory"],"content":"Building ","date":"2020-08-31","objectID":"/inverted_pendolum/:2:0","tags":["electronics","dc-motor","L298n","lamp"],"title":"Inverted Pendulum","uri":"/inverted_pendolum/"},{"categories":["arduino","feedback control theory"],"content":"Components List of used parts\r\r üìü Arduino UNO ‚ö° L298N motor driver ‚öôÔ∏è Geared DC-motor 39.6 mm, 15:1, 12 V DC üîå Capsule Slip Ring AC 240V üìè Wdd35d4-5k Contious Angle Sensor üîå 1 Cannel Relay 5V/230V üìè Potentiometer 50k (linear) üí° E27 Fassung \r\r ","date":"2020-08-31","objectID":"/inverted_pendolum/:2:1","tags":["electronics","dc-motor","L298n","lamp"],"title":"Inverted Pendulum","uri":"/inverted_pendolum/"},{"categories":["arduino","feedback control theory"],"content":"Mechanical Setup To accomplish this symbiosis between this still highly complex balancing problem and the potential usage as a design element, I first had to design a balancing cart üöó with a pivoting E27 socket for the lamp üí°. This brings the extra challenge of feeding a, in this case, 230V, cable through various mountings and controlling it using an ordinary relay. Design-choices\r\r","date":"2020-08-31","objectID":"/inverted_pendolum/:2:2","tags":["electronics","dc-motor","L298n","lamp"],"title":"Inverted Pendulum","uri":"/inverted_pendolum/"},{"categories":["arduino","feedback control theory"],"content":"‚öôÔ∏è DV-Motor (first axel) the L298N Motor Driver Module works up to 12V, without removing the jumper wire, therefore a 12V DV-Motor is a good choice for the setup should have sufficient torque and RPM. In my case around 300-440 RPM (depending on your wheel size) with a 15:1 gear ratio and 10Ncm was enough ‚ùó be careful with the maximum current! The allowed Amps for the L298N Motor Driver Module is 2A (more information here) ","date":"2020-08-31","objectID":"/inverted_pendolum/:2:3","tags":["electronics","dc-motor","L298n","lamp"],"title":"Inverted Pendulum","uri":"/inverted_pendolum/"},{"categories":["arduino","feedback control theory"],"content":"üìè Contious Angle Sensor (second axel) used to monitor the position of the cart üöó relative to its starting position works like a normal potentiometer but allows for more than 360¬∞ turning angle. not the most reliable solution as it produced high noise in the zero orientation =\u003e Quick-fix: use a capacitor as a low-pass filter between the ground and output voltage. ","date":"2020-08-31","objectID":"/inverted_pendolum/:2:4","tags":["electronics","dc-motor","L298n","lamp"],"title":"Inverted Pendulum","uri":"/inverted_pendolum/"},{"categories":["arduino","feedback control theory"],"content":"üìü Arduino the L298 has a 5V regulator and can be used as the power supply for the Arduino (see connection diagram) ‚ùó don‚Äôt mount any high current consumer like the lamp üí° or the motor ‚öô to the 5V output of the board it is not made for such high currents. ","date":"2020-08-31","objectID":"/inverted_pendolum/:2:5","tags":["electronics","dc-motor","L298n","lamp"],"title":"Inverted Pendulum","uri":"/inverted_pendolum/"},{"categories":["arduino","feedback control theory"],"content":"üìè Potentiometer 50k (linear) used to detect the angle of the pendulum additionally used as a mount for the pendulum ","date":"2020-08-31","objectID":"/inverted_pendolum/:2:6","tags":["electronics","dc-motor","L298n","lamp"],"title":"Inverted Pendulum","uri":"/inverted_pendolum/"},{"categories":["arduino","feedback control theory"],"content":"üîå Capsule Slip Ring AC 240V the lamp üí° is powered by an isolated electric circuit with 240V AC the slip ring feeds the power thought the rotational pivot point also used as a mount for the pendulum ","date":"2020-08-31","objectID":"/inverted_pendolum/:2:7","tags":["electronics","dc-motor","L298n","lamp"],"title":"Inverted Pendulum","uri":"/inverted_pendolum/"},{"categories":["arduino","feedback control theory"],"content":"üîå Relay isolates the 12V DC and the 240V AC is triggerd by the Arduino \r\r ","date":"2020-08-31","objectID":"/inverted_pendolum/:2:8","tags":["electronics","dc-motor","L298n","lamp"],"title":"Inverted Pendulum","uri":"/inverted_pendolum/"},{"categories":["arduino","feedback control theory"],"content":"Connecting Motor Driver Board ","date":"2020-08-31","objectID":"/inverted_pendolum/:2:9","tags":["electronics","dc-motor","L298n","lamp"],"title":"Inverted Pendulum","uri":"/inverted_pendolum/"},{"categories":["arduino","feedback control theory"],"content":"Connecting Potentiometer ","date":"2020-08-31","objectID":"/inverted_pendolum/:2:10","tags":["electronics","dc-motor","L298n","lamp"],"title":"Inverted Pendulum","uri":"/inverted_pendolum/"},{"categories":["arduino","feedback control theory"],"content":"Integration of Relay2 ","date":"2020-08-31","objectID":"/inverted_pendolum/:2:11","tags":["electronics","dc-motor","L298n","lamp"],"title":"Inverted Pendulum","uri":"/inverted_pendolum/"},{"categories":["arduino","feedback control theory"],"content":"Control Algorithm In the following section, I will give a brief introduction to the theory of the LQR Controller and provide you with my recommended resources which help you determine the coefficients of the feedback regulator! ","date":"2020-08-31","objectID":"/inverted_pendolum/:3:0","tags":["electronics","dc-motor","L298n","lamp"],"title":"Inverted Pendulum","uri":"/inverted_pendolum/"},{"categories":["arduino","feedback control theory"],"content":"Mathematical representation The simplified system consists of an inverted pendulum which is connected to a motorized card. Without further inspection, we can recognize that we are looking at an unstable system. If the cart is not moved it is nearly impossible to balance the pendulum in the upright position. The objective is it now to design a feedback controller which accelerates the cart enough so that the angle $ \\phi $ of the pendulum is close to 180¬∞. For this we first have to define the nonlinear model: List of Variables\r\r M mass of the cart m mass of the pendulum b coefficient of friction for cart l length to pendulum centre of mass I mass moment of inertia of the pendulum F force applied to the cart x cart position coordinate $\\theta$ pendulum angle from vertical (down) u (input) here equivalent to the Force F \r\r ","date":"2020-08-31","objectID":"/inverted_pendolum/:3:1","tags":["electronics","dc-motor","L298n","lamp"],"title":"Inverted Pendulum","uri":"/inverted_pendolum/"},{"categories":["arduino","feedback control theory"],"content":"LQR Controller The LQR or Linear quadratic regulator is one of many optimal control techniques, which takes into account the whole state vector and computes the control decision based on a linear model. For non-linear plants like our inverted pendulum, the system equations first have to be linearized about the upright (unstable) equilibrium. This consequently means that our LQR controller is only sufficient within small deviations around the upright position. After linearizing we have to calculate the gains $K$, this is done using the script linked here. With all that done, we now can compute the input voltage of the Motor using the following equation: $$ u = -Kx $$ A deeper dive into the theory behind the calculation of the linearized model can be found here! ","date":"2020-08-31","objectID":"/inverted_pendolum/:3:2","tags":["electronics","dc-motor","L298n","lamp"],"title":"Inverted Pendulum","uri":"/inverted_pendolum/"},{"categories":["arduino","feedback control theory"],"content":"Determine grains The script which already includes the linearized model to determine the gains for the LQR Controller can be found here! Tip\r\rWhen you calculate the model-specific gains $K$ it is very important that you measure the weight ‚öñ of the cart üöó and the pendulum + lamp üí° very precisely as the controller is very sensitive!\r\r To furthermore approve your parameters the script [controlled-cart-pendulum.py] from a similar project3 simulates the control behaviour. ","date":"2020-08-31","objectID":"/inverted_pendolum/:3:3","tags":["electronics","dc-motor","L298n","lamp"],"title":"Inverted Pendulum","uri":"/inverted_pendolum/"},{"categories":["arduino","feedback control theory"],"content":"DC-Motor system identification The LQR Controller takes as an input the Force F of the DC-Motor. Therefore the next step is to find the underlying DC-Motor model and estimate the corresponding system parameters. Then the Arduino can change the speed of the engine using the PWM signal. We can model a standard DC-Motor using the following equation: $$ \\frac{d w}{d t}\\left(J+m r^{2}\\right)+w\\left(B+\\frac{k^{2}}{R}\\right)=\\frac{k U}{R} $$ Simplifying this further: To determine the parameters a,b,c we can record several velocity curves with different input voltages. Using the following plot and theses scripts [dc_motor_lqr_control.py,estimate_params.py] we can now find the exact model parameters! Credits to zjor for creating the scripts3 ","date":"2020-08-31","objectID":"/inverted_pendolum/:3:4","tags":["electronics","dc-motor","L298n","lamp"],"title":"Inverted Pendulum","uri":"/inverted_pendolum/"},{"categories":["arduino","feedback control theory"],"content":"Code The code is based on an existing Arduino project3 #define A 9 #define B 1.0 #define C 2.1 #define Kth 61.20847945 #define Kw 10.42165907 #define Kx 16.2303454 #define Kv 13.43669139 #define Ki 0 #define PI 3.1415926535897932384626433832795 //define pins int speed = 9; int front = 6; int back = 7; int lamp = 2; //define constans float wheelCirc = 141.37; float THETA_THRESHOLD = PI / 8; unsigned long now = 0L; unsigned long lastTimeMicros = 0L; //init States float x=0; float d_x; float phi; float d_phi; float phi_sum=0; //usefull variables float pos_last1; float pos_last2; float pos_last3; float pos_last4; float last_phi; float control, u, dt , v_soll; // the setup routine runs once when you press reset: void setup() { // initialize serial communication at 9600 bits per second: Serial.begin(9600); pinMode(speed, OUTPUT); pinMode(front, OUTPUT); pinMode(back, OUTPUT); pinMode(lamp, OUTPUT); digitalWrite(lamp,HIGH); digitalWrite(front, LOW); digitalWrite(back, LOW); pos_last1= mapf(analogRead(A1),0,1023,0,wheelCirc)/1000; pos_last2=pos_last1; pos_last3=pos_last1; pos_last4=pos_last1; last_phi= mapf(analogRead(A0)-512+4 , -512, 512, -PI ,PI ); lastTimeMicros = 0L; //Debugging //Serial.print(\"x\");Serial.print(\"\\t\"); //Serial.print(\"dx\");Serial.println(\"\\t\"); //Serial.print(\"Kv*d_x\");Serial.print(\"\\t\"); //Serial.print(\"Kth*phi\");Serial.print(\"\\t\"); //Serial.print(\"Kw*d_phi\");Serial.print(\"\\t\"); //Serial.print(\"control\");Serial.print(\"\\t\"); //Serial.print(\"u\");Serial.println(\"\\t\"); } float mapf(float x, float in_min, float in_max, float out_min, float out_max) { return (x - in_min) * (out_max - out_min) / (in_max - in_min) + out_min; } void driveMotor(float pwm_out){ analogWrite(speed, fabs(pwm_out)); if (pwm_out \u003e 0) { digitalWrite(front, HIGH); digitalWrite(back, LOW); }else if (pwm_out \u003c 0) { digitalWrite(front, LOW); digitalWrite(back, HIGH); }else{ digitalWrite(front, LOW); digitalWrite(back, LOW); } } boolean isControllable(float phi) { return fabs(phi) \u003c THETA_THRESHOLD; } float saturate(float v, float maxValue) { if (fabs(v) \u003e maxValue) { return (v \u003e 0) ? maxValue : -maxValue; } else { return v; } } float derivative(float x_new, float x_old, float dt){ float d_temp= x_new - x_old; float d_pos = 0; if (fabs(d_temp) \u003c fabs(d_temp+wheelCirc/1000) and (fabs(d_temp) \u003c fabs(d_temp-wheelCirc/1000))){ d_pos= d_temp; }else if (fabs(d_temp+wheelCirc/1000) \u003c fabs(d_temp-wheelCirc/1000)){ d_pos= (d_temp+wheelCirc/1000); }else { d_pos= (d_temp-wheelCirc/1000); } if (fabs(d_pos/dt)\u003e1.1){ d_pos= -d_x*dt; } return - d_pos/dt; } void updateStates(float dt){ //read sensor input (Angle of wheel) float sensor_x = analogRead(A1); float pos_new =mapf(sensor_x,0,1023,0,wheelCirc)/1000; //smoothing the signal input float pos_avg= (pos_last1+pos_last2+pos_last3+pos_last4)/4; float d_x_2 = derivative(pos_new, pos_last2,2*dt); float d_x_3 = derivative(pos_new, pos_last3,3*dt); d_x = (d_x_2+d_x_3)/2; //update state variables x = x + dt*d_x; pos_last4=pos_last3; pos_last3=pos_last2; pos_last2=pos_last1; pos_last1=pos_new; //read sensor phi float sensor_phi = analogRead(A0) - 512; phi = mapf(sensor_phi+8 , -512, 512, -PI, PI ); // map sensor input to correct mean an variance d_phi=(phi-last_phi)/dt; last_phi= phi; phi_sum=phi_sum+dt*phi; if (isControllable(phi)){ phi_sum=0; } //Debugging //Serial.print(sensor_x, 4);Serial.print(\"\\t\"); //Serial.print(sensor_x, 4);Serial.print(\"\\t\"); //Serial.print(pos_new, 4);Serial.print(\"\\t\"); //Serial.print(d_x*1000, 4);Serial.println(\"\\t\"); //Serial.print(d_x_2*1000, 4);Serial.print(\"\\t\"); //Serial.print(d_x_3*1000, 4);Serial.println(\"\\t\"); //Serial.print(d_x_4*1000, 4);Serial.println(\"\\t\"); //Serial.print(phi, 4);Serial.print(\"\\t\"); //Serial.print(d_phi, 4);Serial.print(\"\\t\"); } // the loop routine runs over and over again forever: void loop() { now = micros(); dt = (1.0*(now - lastTimeMicros))/ 1000000; updateStates(dt); if (isControllable(phi)) { digitalWrite(lamp, LOW); control = (Kx * x + Kv * d_x + Kth * phi ","date":"2020-08-31","objectID":"/inverted_pendolum/:4:0","tags":["electronics","dc-motor","L298n","lamp"],"title":"Inverted Pendulum","uri":"/inverted_pendolum/"},{"categories":["arduino","feedback control theory"],"content":"Links http://web.mit.edu/klund/www/papers/Roberge1960.pdf ‚Ü©Ô∏é https://diyi0t.com/relay-tutorial-for-arduino-and-esp8266/ ‚Ü©Ô∏é https://create.arduino.cc/projecthub/zjor/inverted-pendulum-on-a-cart-199d6f ‚Ü©Ô∏é ","date":"2020-08-31","objectID":"/inverted_pendolum/:5:0","tags":["electronics","dc-motor","L298n","lamp"],"title":"Inverted Pendulum","uri":"/inverted_pendolum/"}]